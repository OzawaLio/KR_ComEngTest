# API
: Application Programming Interface의 약자
: 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

# ACK (Acknowledgment)
: 확인 응답
: 송신된 메시지가 수신 측에서 정상적으로 수신되었음을 송신 측으로 확인 응답하는 것으로서 오류제어 및 흐름 제어를 위해 사용된다

# ANSI
: American National Standard Institute
: 1918년 설립된 미국 민간 표준화 대표 단체로서 표준을 조정하고 승인하는 기구이다

# ARP
: 논리적인 IP 주소를 물리적인 MAC 주소로 바꾸어주는 역할을 하는 주소 해석 프로토콜이다

# Applet
: 일반적으로 작게 만들어지며 능동적으로 수행하는 소형 응용 프로그램이다
: 자바 &&&은 JVM을 탑재한 웹브라우저 등에서 실행한 자바 프로그램이다

# JVM(Java Virtual Machine)
: Java 관련 응용 프로그램을 구동하기 위한 주체
: 인터프리터 환경으로 적용 버전을 개발표준에서 명시하여 모든 개발자가 동일한 버전을 적용하는 것이 좋다

# Backbone
: 여러 소형 네트워크를 묶어 대규모 파이프라인을 통해 극도로 높은 대역폭으로 다른 네트워크들의 집합과 연결되는 네트워크를 의미한다
: 사전적 의미로는 척추, 뼈대를 뜻한다

# Bandwidth
: 컴퓨팅에서 일반적으로 초당 여러 비트로 표현되는, 사용 가능하거나 소비된 정보 용적의 비트레이트

# 데이터 웨어하우스
: 시스템이 효율적으로 운영되기 위해 다양한 소스의 데이터를 별도로 추출하여 관리하는 곳

# 데이터 마이닝
: 데이터 웨어하우스의 규모가 크고 복잡할 때 관련 데이터를 찾아내고 필요한 정보나 지식을 생성하는 과정

# 데이터 마트
: 특정 사용자가 관심을 갖는 데이터들을 담은 비교적 작은 규모의 데이터 웨어하우스

# 데이터베이스 정의
: 통합된 데이터 (integrated data)
: 저장된 데이터 (stored data)
: 운영 데이터 (operational data)
: 공용 데이터 (shared data)

# 데이터베이스 특성
: 실시간 접근성 (real time accessibility)
: 내용에 의한 참조 (content reference)
: 동시 공유 (concurrent sharing)
: 계속적 변화 (continuous evolution)

# 데이터베이스 구성요소
: 개체 (entity), 속성 (attribute), 관계 (relationship)

# DBMS의 필수기능
: 정의기능, 조작기능, 제어기능(무결성 유지, 보안, 병행제어)

# ODBC
: 개발언어에 관계없이 사용가능
: 윈도우즈 응용 프로그램에서 다양한 DBMS에 접근하여 사용할 수 있도록 개발한 표준 개방형 응용 프로그램인터페이스 규격이다. 쉽게 말해 공통 인터페이스를 통해 서로 다른 DBMS에 접근할 수 있도록 한 것이다

# 데이터베이스 무결성
: 데이터베이스 내에 지정되는 데이터 값들이 항상 일관성을 갖고 데이터의 유효성, 정확성, 안전성을 유지할 수 있도록 하는 제약조건을 두는 데이터베이스의 특성

# 스키마
: 데이터베이스의 전체적인 구조와 제약조건에 대한 명세를 기술한 것.
: 컴파일되어 데이터 사전(Data Dictionary = 시스템 카탈로그 = 메타 데이터)에 저장됨

# 데이터베이스 언어
: DDL = create, alter, drop
: DML = select, update, insert, delete
: DCL = commit, rollback, grant, invoke

# 스키마 3계층
: 외부스키마, 개념스키마, 내부스키마

# 데이터베이스 설계순서
: 1. 요구조건분석 > 명세서
: 2. 개념적설계 > 스키마
: 3. 논리적설계 (정규화과정) > 논리스키마
: 4. 물리적설게 > 물리스키마
: 5. 구현 > DB구현

# 데이터 모델
: 현실 세계를 DB에 표현하는 중간과정으로서 DB 설계과정에서 데이터의 구조를 표현하는 것
: 현실세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형
: 구성요소 > 개체, 속성, 관계
: 종류 > 개념적, 논리적, 물리적
: 표시요소 > 구조, 연산, 제약조건

# 관계 데이터 모델
: 개체 집합에 대한 속성관계를 표현하기 위해 개체를 릴레이션. 즉, 테이블로 사용하고 개체 집합들 사이의 관계를 공통속성으로 연결하는 독립된 형태의 데이터모델(기본키, 외래키로 표현)
: N-M 관계 표현 가능

# 계층 데이터 모델
: 데이터베이스의 논리적 구조표현을 Tree 형태로 표현한 데이터 모델
: N-M 관계 표현 불가능, 1-N 관계로 표현

# 네트워크 데이터 모델
: 데이터베이스의 논리적 구조표현을 그래프 형태로 표현한 데이터 모델
: N-M 관계 표현 불가능, 1-N 관계로 표현

# 슈퍼키
: 튜플을 구별하기 위해 한 개 이상의 속성 집합으로 이루어진 키
: 유일성은 만족, 최소성은 만족하지 않는 키

# 후보키
: 유일성, 최소성을 모두 만족하는 키

# 기본키
: 후보키 중에서 대표로 지정된 키 (중복, null 불가)

# 대체키
: 기본키를 제외한 후보키

# 외래키
: 참조하는 릴레이션의 기본키

# 개체 무결성
: 한 릴레이션의 기본키를 구성하는 어떠한 속성도 null 값이나 중복 값을 가질 수 없음

# 참조 무결성
: 참조할 수 없는 외래키 값을 가질 수 없음

# 영역 무결성
: 속성값들은 정해진 범위 내에 있어야 한다

# 이상
: 사용자의 의도와 다르게 데이터가 삽입(삽입이상), 삭제(삭제이상), 갱신(갱신이상)이 되는 현상

# 관계 대수
: 튜플의 집합이 릴레이션을 처리하기 위한 연산의 집합

# 뷰(View)
: 데이터베이스 내에 존재하는 하나 이상의 테이블로부터 유도된 가상의 테이블이다
: 데이터의 논리적 독립성 제공하고 보안성이 향상되며 여러 사용자의 요구를 지원한다

# 뷰의 장점
: 논리적 데이터 독립성을 제공
: 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해준다
: 사용자의 데이터 관리를 간단하게 해준다
: 접근 제어를 통한 자동 보안이 제공된다

# 뷰의 단점
: 독립적인 인덱스를 가질 수 없다
: 뷰의 정의를 변경할 수 없다
: 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름

# 뷰 설계순서
: 대상 테이블을 선정 > 대상 컬럼을 선정 > 정의서를 작성

# 뷰 설계시 고려사항
: 테이블 구조가 단순화될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
: 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시해야 함
: 데이터의 보안 유지를 고려하여 설계

# CASCADE
: 관계된 것을 따라가서 연속적으로 삭제할 때 사용

# WITH GRANT OPTION
: 사용자가 부여받은 권한을 다른 사용자에게 부여할 수 있는 권한을 부여함

# 트리거(Trigger)
: DB에서 이벤트가 발생할 때마다 관련된 작업이 자동으로 수행되는 절차형 SQL
: DB에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용
: 구문 내에 DCL을 사용할 수 없으며 DCL이 포함된 프로시저나 함수를 호출하여도 오류 발생
: 오류가 있는 경우 데이터에도 영향을 미침
: table과는 별도로 DATABASE에 저장
: view에 대해서가 아니라 table에 관해서만 정의가능

# 변수
: 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간

# 연산자 우선순위
: 단항연산자 > 이항연산자(산술, 시프트, 관계, 비트, 논리) > 삼항연산자 > 대입연산자 > 순서연산자

# 객체지향 프로그래밍
: 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 프로그램을 작성할 수 있도록 한 프로그래밍 기법

# 객체지향 프로그래밍 언어의 장점
: 상속을 통한 재사용과 시스템의 확장이 용이
: 코드의 재활용성이 높음 
: 자연적인 모델링에 의해 분석과 설계를 쉽고 효율적으로 함
: 사용자와 개발자 사이의 이해를 쉽게 해줌
: 대형 프로그램의 작성이 용이
: 소프트웨어 개발 및 유지보수가 용이 

# 객체지향 프로그래밍 언어의 단점
: 프로그래밍 구현을 지원해 주는 정형화된 분석 및 설계 방법이 없음
: 구현시 처리 기간이 지연됨

# 객체지향 프로그래밍 언어 특징
: 캡슐화, 정보은닉, 추상화, 상속성, 다형성

# 객체지향 프로그래밍 언어 구성요소
: 객체, 클래스, 메시지

# 스크립트 언어의 종류
: 자바스크립트, ASP, JSP, PHP, python

# 선언형 언어의 종류
: HTML, LISP, PROLOG, XML, Haskell

# 예외
: 프로그램의 정상적인 실행을 방해하는 조건이나 상태

# 예외처리
: 예외가 발생했을 때 프로그래머가 해당 문제에 대비해 작성해 놓은 처리 루틴을 수행하도록 하는것

# 현행 시스템 파악 절차
: 1단계 > 시스템 구성 파악, 시스템 기능 파악, 시스템 인터페이스 파악
: 2단계 > 아키텍처 구성 파악, 소프트웨어 구성 파악
: 3단계 > 하드웨어 구성 파악, 네트워크 구성 파악

# 운영체제
: 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어

# DBMS
: 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어

# DBMS의 종류
: Oracle, IBM DB2, Microsoft SQL Server, MySQL, SQLite, MongoDB, Redis

# DBMS 관련 요구사항 식별시 고려사항
: 가용성, 성능, 기술지원, 상호호환성, 구축비용

# Web Server 
: 정적 웹 서비스를 수행하는 미들웨어로서 웹 브라우저 화면에서 요청하는 정적 파일을 제공 
: Apache, Nginx, IIS(Internet Information Server), GWS(Google Web Server)

# WAS (Web Application Server)
: 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어 
: 웹서버와 DB 서버 또는 웹 서버와 file 서버 사이에서 인터페이스 역할을 수행

# WAS 종류
: Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere

# WAS 관련 요구사항 식별시 고려사항
: 가용성, 성능, 기술지원, 구축비용

# 가비지 컬렉션
: 실제로는 사용되지 않으면서 가용 공간 리스트에 반환되지 않는 메모리 공간인 가비지를 강제로 해제하여 사용할 수 있도록 하는 메모리 관리 기법

# 요구사항
: 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건 등을 나타낸다
: 기능, 비기능, 시스템, 사용자 요구사항

# 요구사항 개발 프로세스
: 도출 > 분석 > 명세 > 확인

# 요구사항 도출
: 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정
: 도출기법 = 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스

# 요구사항 분석
: 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
: 사용기법 = 요구사항 분류, 개념 모델링, 요구사항 할당, 요구사항 협상, 정형 분석

# 요구사항 명세
: 요구사항을 체계적으로 분석한 후 승인될 수 있도록 문서화하는 것을 의미한다

# 요구사항 확인
: 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동
: 요구사항 검토, 프로토타이핑, 모델 검증, 인수테스트

# 요구사항 분류
: 요구사항을 명확히 확인할 수 있도록 분류하는 것

# 개념 모델링
: 요구사항을 보다 쉽게 이해할 수 있도록 현실 세계의 상황을 단순화하여 개념적으로 표현한 것을 모델이라고 하며, 이러한 모델을 만드는 과정

# 요구사항 할당
: 요구사항을 만족시키기 위한 구성 요소를 식별하는 것

# 요구사항 협상
: 요구사항이 서로 충돌될 경우 이를 적절히 해결하는 과정

# 정형 분석
: 구문과 의미를 갖는 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현한 후 이를 분석하는 과정

# 구조적 다이어그램 종류
: 클래스 다이어그램, 객체 다이어그램, 컴포넌트 다이어그램, 배치 다이어그램, 복합체 구조 다이어그램, 패키지 다이어그램

# 행위 다이어그램 종류
: 유스케이스 다이어그램, 시퀀스 다이어그램, 커뮤니케이션 다이어그램, 상태 다이어그램, 활동 다이어그램, 상호작용 개요 다이어그램, 타이밍 다이어그램

# 유스케이스 다이어그램 표현할 때 사용되는 구성요소
: Actor, System, Use case, relationship

# 활동 다이어그램
: 사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것
: 자료 흐름도와 유사
: 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름 순서에 따라 표현한 것
: 액션, 액티비티, 노드, 스윔레인 등으로 구성

# 클래스 다이어그램
: 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램
: 시스템을 구성하는 요소를 문서화하는데 사용
: 코딩에 필요한 객체의 속성, 함수 등의 정보를 잘 표현하고 있어 시스템을 모델링하는데 자주 사용된다
: 클래스 제약조건, 관계 등으로 구성된다

# 시퀀스 다이어그램
: 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정을 액터, 객체, 메시지 등의 요소를 사용하여 그램으로 표현한것
: 시스템이나 객체들이 상호 작용 과정에서 주고받는 메시지를 표현한다
: 각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인하는 데 사용
: 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현한다
: 주로 기능 모델링에서 작성한 유스케이스 명세서를 하나의 표현 범위를 하지만, 하나의 클래스에 포함된 오퍼레이션을 하나의 범위로 표현하기도 한다

# 커뮤니케이션 다이어그램
: 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정을 엑터, 객체, 링크, 메시지 등의 요소를 사용하여 그림으로 표현
: 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데, 메시지뿐만 아니라 객체들 간의 관계까지 표현
: 동작에 참여하는 객체들 사이의 관계를 파악하는데 사용
: 클래스 다이어그램에서 관계가 제대로 표현됬는지 점검하는 용도로도 사용
: 초기에는 협업 다이어그램이라고 불렸다

# 상태 다이어그램
: 객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것
: 어떤 이벤트에 의해 객체 자신이 속한 클래스의 상태 변화나 객체가 다른 객체와 상호 작용하는 과정에서의 상태 변화를 표현
: 특정 객체가 어떤 이벤트에 의해 상태 변환 과정이 진행되는지 확인하는데 사용
: 시스템에서 상태 변환 이벤트를 확인할 필요가 있는 객체만을 대상으로 그림

# 유스케이스 명세서
: 유스케이스 안에서의 액터와 시스템 간의 상호 작용 과정을 글로 자세히 표현한 것
: 유스케이스 다이어그램에 있는 모든 유스케이스에 대해 개별적으로 작성해야한다
: 작성된 사건의 흐름을 참고하여 활동 다이어그램을 작성한다

# exe
: 실행 가능한 파일의 확장자

# dll
: 프로그램 설치 과정에서 필요한 경우 호출해서 사용하는 동적 링크 라이브러리 파일의 확장자

# ini
: windows 기반 컴퓨터의 기본 구성 값을 변경해야 하는 경우 사용되는 설정 초기화 파일의 확장자

# chm
: HTML로 구성된 도움말 파일의 확장자

# 개념적 데이터 모델
: 현실 세계에 대한 인간의 이해를 돕기 위해 현실세계에 대한 인식을 추상적 개념으로 표현하는 과정
: 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현
: 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고도 함
: 대표적인 개념적 데이터 모델로는 E-R 모델이 있다

# 논리적 데이터 모델
: 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
: 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현
: 논리적 데이터 모델은 데이터 간의 관계를 어떻게 표현하느냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분

# 정규화
: 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정
: 가능한 한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것

# 제1정규화
: 도메인이 원자값
: 반복되는 속성이나 Group 속성제거
: 모든 속성은 반드시 하나의 값을 가져야함(반복되는 형태 있으면 안됨)

# 제2정규화
: 부분적 함수 종속 제거
: 주식별자에 완전하게 종속되지 않는 속성 제거

# 제3정규화
: 이행적 함수 종속성 제거
: 비식별자에 종속되는 속성 제거
: 주식별자에 이행종속(transitive dependency)되는 속성 제거

# 제4정규화
: 다치 종속성 제거
: 주식별자에 다가종속(multi-valued dependency)되는 속성을 두가지 이상 두지 않음
: 어떠한 관계구조가 바람직한 것인지, 바람직하지 못한 관계를 어떻게 분해하여야 하는지에 관한 구체적 판단기준 제공 

# 반정규화
: 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위
: 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있음
: 반정규화 방법 > 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가

# 반정규화를 수행해야 하는 경우
: 정규화로 인해 수행속도가 느려지는 경우
: 많은 범위의 데이터를 자주 처리해야하는 경우
: 특정 범위의 데이터지만 자주 처리해야하는 경우
: 처리 범위를 줄이는 것 이외에는 수행 속도 개선 방법이 없을 때

# 클러스터
: 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법

# 클러스터의 특징
: 클러스터링 된 테이블은 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하시킨다
: 데이터의 분포도가 넓을수록 유리

# 클러스터 대상 테이블
: 분포도가 넓은 테이블
: 대량의 범위를 자주 조회하는 테이블
: 입력, 수정, 삭제가 자주 발생하지 않는 테이블
: 자주 조인되어 사용되는 테이블
: ORDER BY, GROUP BY, UNION이 빈번한 테이블

# 파티션
: 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말함

# 파티션의 장점
: 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상된다
: 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상
: 파티션별로 백업 및 복구를 수행하므로 속도가 빠르다
: 시스템 장애 시 데이터 손상 정도를 최소화할 수 있다
: 데이터 가용성이 향상됨
: 파티션 단위로 입출력을 분산시킬 수 있음

# 파티션의 단점
: 하나의 테이블을 세분화하여 관리하여 세심한 관리가 요구됨
: 테이블간 조인에 대한 비용이 증가
: 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨

# 파티션의 종류
: 범위분할 > 지정한 열의 값을 기준으로 분할
: 해시분할 > 해시 함수를 적용한 결과 값에 따라 데이터를 분할
: 조합분할 > 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할

# 데이터베이스 용량 분석 절차
: 기초 자료를 수집하여 용량을 분석
: 분석된 자료를 바탕으로 DBMS에 이용될 오브젝트별 용량을 산정
: 테이블과 인덱스의 테이블스페이스 용량을 산정
: 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량 산정

# DB 용량 설계 시 데이터 접근성을 향상시키기 위한 방법
: 테이블스페이스와 임시 테이블 스페이스를 분리하여 구성
: 테이블을 마스터 테이블과 트랜잭션 테이블로 분류

# 통합구현
: 사용자 요구사항의 해결 및 새로운 서비스 창출을 위해 단위 기능을 하는 모듈 간의 연계와 통합을 의미
: 시스템 아키텍처 구성, 송수신 방식 및 모듈 구현 방식에 따라 다양하기 때문에 구축 환경과 사용자 요구사항에 따라 적합한 방식을 설계해야 함

# 통합구현의 구성요소
: 송수신시스템, 모듈, 중계시스템, 연계 데이터, 네트워크

# 연계 데이터 식별 및 표준화 절차
: 연계 범위 및 항목 정의 > 연계 코드 변환 및 매핑 > 연계 데이터 식별자와 변경 구분 추가 > 연계 데이터 표현 방법 정의 > 연계 정의서 및 명세서 작성

# 직접 연계 방식
: 중간 매개체 없이 송수신 시스템이 직접 연계하는 방식
: DB Link, API, DB Connection, JDBC

# 직접 연계 방식의 장점
: 연계 및 통합구현이 단순하고 용이
: 중간 매개체 없이 직접 연계되기 때문에 데이터 연계 처리 성능이 뛰어남
: 개발 비용이 저렴하고 기간이 짧다

# 직접 연계 방식의 단점
: 송수신 시스템 간 결합도가 높아 시스템 변경시 오류가 발생할 수 있음
: 보안을 위한 암호화, 복호화 처리와 비즈니스 로직을 적용하기 어려움
: 연계 및 통합이 가능한 시스템 환경이 제한적

# 간접 연계 방식
: 송수신 시스템 사이에 중간 매개체를 두어 연계하는 방식
: 연계 솔루션, ESB, Socket, Web Service

# 간접 연계 방식의 장점
: 서로 다른 네트워크, 프로토콜 등 다양한 환경의 연계 및 통합이 가능
: 송수신 시스템 간 인터페이스가 변경되어도 오류 없이 서비스가 가능
: 보안 품질 보장과 비즈니스 처리를 위한 로직을 쉽게 반영할 수 있음

# 간접 연계방식의 단점
: 연계 매커니즘과 아키텍처가 복잡함
: 중간 매개체로 인해 성능이 저하될 수 있음
: 개발 및 적용기간이 비교적 길다

# EAI
: 기업 내 각종 어플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션

# ESB
: 어플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
: EAI와 유사하지만 어플리케이션 보다는 서비스 중심의 통합을 지향

# XML
: 웹브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위해 개발된 다목적 마크업 언어
: 유니코드를 기반으로 다국어 지원

# SOAP(Simple Object Access Protocol)
: 컴퓨터 네트워크 상에서 HTTP(S), SMTP등을 이용하여 XML을 교환하기 위한 통신 규약
: 주요요소 > Envelope, Header, Body

# WSDL(Web Service Description Language)
: 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어
: XML로 작성되며 UDDI의 기초가 됨

# UDDI(Universal Description, Discovery and Integration)
: 인터넷에서 전 세계의 비즈니스 업체 목록에 자신의 목록을 등록하기 위한 확장성 생성 언어(XML) 기반의 규격

# 연계테스트
: 구축된 연계 시스템과 연계 시스템의 구성 요소가 정상적으로 동작하는지 확인하는 활동
: 테스트케이스 작성 > 테스트 환경 구축 > 테스트 수행 > 테스트 수행 결과 검증 순으로 진행

# 연계테스트 수행 결과 검증 방법
: 운영 DB 테이블의 건수를 확인
: 테이블 또는 파일을 열어 데이터를 확인하는 방법
: 파일 생성 위치에서 파일 생성 여부 및 파일 크기를 확인하는 방법
: 연계 서버에서 제공하는 모니터링 현황 확인 방법
: 로그 확인하는 방법

# 개발환경 구축
: 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는것

# 웹 서버
: 클라이언트로부터 직접 요청을 받아 처리하는 서버로, 저용량의 정적 파일들을 제공

# 웹 서버 기능
: HTTP(S) 지원 > 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜 
: 통신기록 > 처리한 요청들을 로그 파일로 기록하는 기능 
: 정적파일관리 > HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능
: 대역폭제한 > 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
: 가상호스팅 > 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
: 인증 > 사용자가 합법적인 사용자인지를 확인하는 기능 

# DB 서버
: DB와 이를 관리하는 DBMS를 운영하는 서버

# file 서버
: DB에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버

# 요구사항 관리 도구
: 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어
: JIRA, IBM DOORS, inteGREAT, Reatify, Trello

# 설계/모델링 도구
: UML을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 SW
: DB Designer, PlantUML, ArgoUML

# 구현 도구
: 개발 언어를 통해 어플리케이션의 실제 구현을 지원하는 SW
: Eclipse, IntelliJ IDEA, Visual Studio, Netbeans, Node.js

# 빌드 도구
: 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 SW
: Ant, Gradle, Maven, Jenkins

# 테스트 도구
: 모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 SW
: CppUnit, JUnit, HttpUnit, NUnit, SpringTest

# 형상관리 도구
: 산출물들을 버전별로 관리하여 품질 향상을 지원하는 SW
: GIT, CVS, Subversion, Mercurial

# 개발언어 선정 기준
: 적정성, 효율성, 이식성, 친밀성, 범용성

# CBD(Component Based Development)
: 재사용 가능한 컴포넌트 개발 또는 상용 컴포넌트를 조합하여 응용 시스템을 구축하는 방법론 

# 연관 클래스
: 두 클래스가 연관 관계에 있을 때 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 사용되는 클래스이다
: 두 클래스의 연관 관계를 나타내는 선의 가운데로부터 점선을 이어 표시한다

# 결합도
: 모듈간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
: (강) 내용, 공통, 외부, 제어, 스탬프, 자료, 메시지 (약) LOW

# 자료 결합도
: 모듈간의 인터페이스가 자료 요소로만 구성될 때의 결합도

# 스탬프 결합도 
: 모듈간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도 

# 제어 결합도
: 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도 

# 외부 결합도
: 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도 

# 공통 결합도
: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 

# 내용 결합도 
: 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 

# 응집도
: 명령어나 호출문 등 모듈 내부의 요소들이 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미
: (강) 기능적, 순차적, 교환적, 절차적, 시간적, 논리적, 우연적 (약) HIGH

# 기능적 응집도
: 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

# 순차적 응집도
: 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도

# 교환(통신)적 응집도
: 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도

# 절차적 응집도
: 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도

# 시간적 응집도
: 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도

# 논리적 응집도
: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

# 우연적 응집도
: 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도 

# 공통 모듈
: 여러 프로그램에서 공통적으로 사용할 수 있는 모듈을 의미, 자주 사용되는 계산식이나 사용자 인증과 같은 기능이 여기에 해당됨
: 재사용성의 확보와 중복 개발 회피를 통해 개발에 소모되는 자원 절약
: 구현시 다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 명세 기법 준수해야함

# 공통 모듈의 명세 기법
: 정확성 > 시스템 구현시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성한다
: 명확성 > 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성한다
: 완전성 > 시스템 구현을 위해 필요한 모든 것을 기술한다
: 일관성 > 공통 기능들 간 상호 충돌이 발생하지 않도록 작성한다
: 추적성 > 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성한다

# 동적 SQL
: 조건에 따라 SQL 구문을 동적으로 변경하여 처리할 수 있는 SQL 처리 방식

# 프레임워크
: SW에서 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스등을 모아둔 집합체

# 프레임워크의 특성
: 모듈화 > 설계 및 구현의 변경에 따른 영향을 최소화함으로서 소프트웨어의 품질을 향상시킴
: 재사용성 > 재사용 가능한 모듈들을 제공함으로서 개발자의 생산성을 향상시킴
: 확장성 > 다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 어플리케이션 개발 가능
: 제어의 역흐름 > 개발자가 관리하고 통제해야 하는 객체들의 제어 권한을 프레임워크에 넘김으로서 생산성 향상

# 배치 프로그램
: 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것을 의미 
: 수행주기에 따라 > 정기배치, 이벤트성배치, On-Demand 배치로 나누어진다

# 배치 프로그램의 필수 요소
: 대용량 데이터, 자동화, 견고성, 안정성/신뢰성, 성능

# 사용자 인터페이스
: 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치 or SW

# 사용자 인터페이스 기본 원칙
: 직관성 > 누구나 쉽게 이해하고 사용할 수 있어야 한다
: 유효성 > 사용자의 목적을 정확하고 완벽하게 달성해야 한다
: 학습성 > 누구나 쉽게 배우고 익힐 수 있어야 한다
: 유연성 > 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다

# 와이어프레임
: 기획 단계 초기에 제작. 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계
: 제작시 각 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계

# 목업
: 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
: 시각적으로만 구성 요소를 배치하는 것

# 스토리보드
: 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름을 묘사한 문서
: 디자이너와 개발자가 최종적으로 참고하는 작업 지침서
: 정책, 프로세스, 콘텐츠 구성, 와이어프레임, 기능 정의 등 서비스 구축을 위한 모든 정보가 들어있다
: 우측에는 화면에 대한 설명, 전반적인 로직, 분기처리, 예외처리 등이  작성되는 부분이 있으며, 이를 디스크립션 이라고 부른다

# 프로토타입
: 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로서 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형

# 프로토타입 장점
: 사용자를 설득하고 이해시키기 쉽다
: 요구사항과 기능의 불일치 등으로 인한 혼선을 예방하여 개발시간 단축
: 오류를 사전에 발견 가능

# 프로토타입 단점
: 작업시간이 증가될 수 있으며, 필요 이상으로 자원을 소모할 수 있음
: 부분적으로 프로토타입을 진행하다보면 중요한 작업이 생략될 수 있음

# 유스케이스
: 사용자 측면에서의 요구사항으로 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술
: 사용자의 요구사항을 빠르게 파악하여 프로젝트 초기에 시스템의 기능적인 요구를 결정하고 결과를 문서화할 수 있음

# 웹의 3요소
: 표준, 접근성, 호환성

# UI 요구사항 확인
: 새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해서 작성하는 단계
: 목표정의 > 활동사항 정의 > UI 요구사항 작성

# 인터뷰 진행시 유의사항
: 가능하면 개별적으로 진행
: 가능한 많은 사람을 인터뷰하여 다양한 의견을 수렴하되 다수의 의견으로 중요한 의견을 놓치지 않도록 주의
: 한시간내로 끝낼 것
: 인터뷰는 반드시 사용자 리서치를 시작하기 전에 해야함

# UI 요구사항 작성 순서
: 요구사항 요소 확인 > 정황 시나리오 작성 > 요구사항 작성

# 정황시나리오
: 사용자의 요구사항을 도출하기 위해 작성하는 것으로, 사용자가 목표를 달성하기 위해 수행하는 방법을 순차적으로 묘사한 것

# UI 흐름 설계 순서
: 기능 작성 > 입력 요소 확인 > 유스케이스 설계 > 기능 및 양식 확인

# UI 상세 설계 순서
: 요구사항 확인 > UI 설계서 표지 및 개정 이력 작성 > UI 구조 설계 > 메뉴 구조 설계 > 화면 설계

# 어플리케이션 테스트
: 어플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차

# 테스트 케이스 설계 기법
: 명세기반 기법(블랙박스 테스트)
: 구조기반 기법(화이트박스 테스트)
: 경험기반 기법

# 어플리케이션 테스트의 필요성
: 프로그램 실행 전 오류를 발견하여 예방 가능
: 제품의 신뢰도 향상
: 단순한 오류 발견 뿐만 아니라 새로운 오류의 유입도 예방 가능
: 최소한의 시간과 노력으로 많은 결함을 찾을 수 있음

# 어플리케이션 테스트 기본 원리
: 완벽한 테스트 불가능
: 파레토 법칙
: 살충제 패러독스
: 테스팅은 정황에 의존
: 오류-부재의 궤변

# 정적 테스트
: 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트
: 워크스루, 인스펙션, 코드검사

# 동적 테스트
: 프로그램을 실행하여 오류를 찾는 테스트
: 블랙박스 테스트, 화이트박스 테스트 

# 명세기반 테스트
: 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
: 동등분할, 경계 값 분석

# 구조기반 테스트
: 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
: 구문 기반, 결정 기반, 조건 기반

# 경험기반 테스트
: 테스터의 경험을 기반으로 수행하는 테스트
: 사용자의 요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적
: 에러 추정, 체크 리스트, 탐색적 테스팅

# 검증 테스트
: 개발자의 시각에서 제품의 생산 과정을 테스트

# 확인 테스트
: 사용자의 시각에서 생산된 제품의 결과를 테스트

# 회복 테스트
: 시스템에 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인하는 테스트

# 안전 테스트
: 시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인하는 테스트

# 강도 테스트
: 시스템 과부하 시에도 소프트웨어가 정상적으로 실행되는지 확인하는 테스트

# 성능 테스트
: SW의 실시간 성능이나 전체적인 효율성을 진단하는 테스트

# 구조 테스트
: SW 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트

# 회귀 테스트
: SW의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트

# 병행 테스트
: 변경된 SW와 기존 SW에 동일한 데이터 입력하여 결과를 비교하는 테스트

# 화이트박스 테스트
: 원시코드를 오픈시킨 상태에서 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법

# 화이트박스 테스트 종류
: 기초 경로검사 & 제어 구조 검사(조건 검사, 루프 검사, 데이터 흐름 검사)

# 블랙박스 테스트
: SW의 내부구조를 모르는 상태에서 동작을 검사하는 방법
: SW가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트

# 블랙박스 테스트 종류
: 동치 분할 검사 > 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력자료에 맞는 결과가 나오는지 확인
: 경계값 분석 > 입력조건의 경계값을 테스트 케이스로 선정하여 검사
: 원인-효과 그래프 검사 > 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 후 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
: 오류 예측 검사 > 과거의 경험이나 감각으로 테스트하는 기법
: 비교 검사 > 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법

# 단위 테스트
: 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트
: 종류 = 구조기반 테스트(화이트박스), 명세기반 테스트(블랙박스)

# 통합 테스트
: 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
: 종류 = 비점진적 통합 방식(빅뱅 통합), 점진적 통합 방식(하향식, 상향식, 혼합식 통합)

# 시스템 테스트
: 개발된 SW가 해당 시스템에서 완벽하게 수행되는가를 점검하는 테스트
: 종류 = 기능적 요구사항(블랙박스), 비기능적 요구사항(화이트박스)

# 인수 테스트
: 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법

# 인수 테스트 종류
: 사용자 인수 테스트, 운영상 인수 테스트, 계약 인수 테스트, 규정 인수 테스트, 알파 테스트, 베타 테스트

# 하향식 통합 테스트
: 프로그램 상위 모듈에서 하위 모듈방향으로 통합하면서 테스트 하는 기법
: 테스트 초기부터 사용자에게 시스템 구조 보여줄 수 있음

# 하향식 통합 테스트 방법
: 주요 제어모듈은 작성된 프로그램을 사용하고, 주요 제어모듈의 종속모듈은 Stub으로 대체
: 깊이 우선 or 넓이 우선 통합방식에 따라 하위 모듈인 Stub이 실제 모듈로 교체됨
: 모듈이 통합될 때마다 테스트 실시
: 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시

# 상향식 통합 테스트
: 프로그램의 하위 모듈에서 상위 모듈 방향으로 테스트 하는 기법
: 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터 필요

# 상향식 통합 방법
: 하위 모듈들을 Cluster로 결합
: 상위 모듈에서 데이터 입출력을 확인하기 위해 더미 모듈인 Dirver 작성 
: 통합된 클러스터 단위로 테스트 진행
: 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체 

# 혼합식 통합테스트
: 하위수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식

# 어플리케이션 테스트 프로세스
: 테스트 계획 > 테스트 분석 및 디자인 > 테스트 케이스 및 시나리오 작성 > 테스트 수행 > 테스트 결과 평가 및 리포팅 > 결함 추적 및 관리

# 어플리케이션 테스트의 산출물
: 테스트 계획서, 테스트 케이스 ,테스트 시나리오, 테스트 결과서

# 프로세스 맵
: 상위 프로세스와 하위 프로세스의 체계를 도식화하여 전체 업무의 청사진을 표현하는 것

# 프로세스 Task 정의서 
: 프로세스의 필수 구성 요소 중 기대하는 결과물을 산출하기 위해 Task들이 어떻게 운영되어야 하는지에 대한 문서

# 테스트 계획서
: 테스트 목적, 범위, 일정, 수행절차, 대상 시스템 구조, 조직의 역할 및 책임 등 테스트 수행을 계획한 문서

# 테스트 케이스 
: 사용자의 요구사항을 얼마나 준수하는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목 명세서
: 미리 설계하면 테스트 오류를 방지할 수 있고 테스트 수행에 필요한 자원의 낭비를 줄일 수 있음
: 가장 이상적인 설계 시점은 시스템 설계시 작성하는 것

# 테스트 시나리오
: 테스트를 수행할 여러 개의 테스트 케이스의 동작 순서를 기술한 문서 
: 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있음
: 테스트 순서를 미리 정함으로써 테스트 항목을 빠짐없이 수행

# 테스트 결과서 
: 테스트 결과를 비교 & 분석한 내용을 정리한 문서 

# 결함 관리 프로세스(판별 중심)
: 에러 발견 > 에러 등록 > 에러 분석 > 결함 확정 > 결함 할당 > 결함 조치 > 결함 조치 검토 및 승인

# 결함 관리 프로세스(처리 중심)
: 결함 관리 계획 > 결함 기록 > 결함 검토 > 결함 수정 > 결함 재확인 > 결함 상태 추적 및 모니터링 활동 > 최종 결함 분석 및 보고서 작성

# 테스트 케이스 작성 순서
: 테스트 계획 검토 및 자료 확보 > 위험 평가 및 우선순위 결정 > 테스트 요구사항 정의 > 테스트 구조 설계 및 테스트 방법 결정 > 테스트 케이스 정의 > 테스트 케이스 타당성 확인 및 유지 보수

# 테스트 시나리오 작성시 유의사항
: 시스템별, 모듈별, 항목별 등과 같이 여러개의 시나리오로 분리해서 작성해야함
: 테스트 시나리오는 사용자의 요구사항과 설계 문서등을 토대로 작성해야함
: 각각의 테스트 항목은 식별자 번호, 순서 번호, 테스트 데이터, 테스트 케이스, 예상 결과, 확인등을 포함해서 작성해야함
: 테스트 시나리오는 유스케이스간 업무 흐름이 정상적인지를 테스트할 수 있도록 작성해야함
: 테스트 시나리오는 개발된 모듈 또는 프로그램 간의 연계가 정상적으로 동작하는지 테스트할 수 있도록 작성해야함 

# 테스트 오라클
: 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 및 활동을 의미

# 테스트 오라클 특징
: 제한된 검증 > 모든 테스트 케이스에 적용할 수 없다
: 수학적 기법 > 수학적 기법을 이용하여 테스트 오라클의 값을 구할 수 있다
: 자동화 기능 > 테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정등을 자동화 할 수 있다

# 테스트 오라클 종류
: 참 오라클, 샘플링 오라클, 추정 오라클, 일관성 검사

# 참 오라클
: 모든 테이트 케이스 입력 값에 대해 기대하는 결과를 제공하는 오라클로, 발생된 모든 오류 검출

# 샘플링 오라클
: 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클

# 추정 오라클
: 샘플링 오라클을 개선한 오라클로, 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클

# 일관성 검사 오라클
: 어플리케이션의 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지 확인하는 오라클 

# 테스트 자동화
: 반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용함으로써 쉽고 효율적으로 테스트를 수행할 수 있도록 한 것

# 테스트 자동화 도구 장점 
: 테스트 데이터의 재입력, 재구성같은 반복적인 작업을 자동화함으로서 인력 및 시간을 줄일 수 있음
: 다중 플랫폼 호환성, 소프트웨어 구성, 기본 테스트등 향상된 테스트 품질을 보장
: 사용자의 요구사항 등을 일관성 있게 검증
: 테스트 결과에 대한 객관적인 평가 기준을 제공
: 테스트 결과를 그래프 등 다양한 표시 형태로 제공
: UI가 없는 서비스도 정밀 테스트가 가능

# 테스트 자동화 도구 단점
: 테스트 자동화 도구의 사용 방법에 대한 교육 및 학습이 필요
: 자동화 도구를 프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요
: 비공개 상용 도구의 경우 고가의 추가 비용 발생

# 테스트 자동화 수행시 고려사항
: 테스트 절차를 고려하여 재사용 및 측정이 불가능한 테스트 프로그램은 제외 
: 용도에 맞는 적절한 도구를 선택해서 사용 
: 자동화 도구의 환경 설정 및 습득 기간을 고려해서 프로젝트 일정을 계획 
: 프로젝트 초기에 테스트 엔지니어의 투입시기 계획 

# 테스트 자동화 도구
: 정적 분석 도구, 테스트 실행도구, 성능테스트 도구, 테스트 통제 도구, 테스트 하네스 도구

# 정적 분석 도구
: 프로그램을 실행하지 않고 분석하는 도구 
: 소스 코드에 대한 코딩표준, 코딩 스타일, 코드 복잡도 및 남은 결함등을 발견하기 위해 사용 
: 테스트를 수행하는 사람이 작성된 코드를 이해하고 있어야만 분석 가능 

# 테스트 하네스의 구성요소
: 테스트 드라이버 
: 테스트 스텁 
: 테스트 슈트 > 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
: 테스트 케이스 
: 테스트 스크립트
: 목 오브젝트 > 사전에 사용자의 행위를 조건부로 입력하면 조건에 따라 예정된 행위를 수행하는 객체 

# 결함
: SW가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것을 의미

# 결함 추적 순서
: 결함 등록 > 결함 검토 > 결함 할당 > 결함 수정 > 결함 조치 보류 > 결함 종료 > 결함 해제

# 결함 분류
: 시스템 결함
: 기능 결함
: GUI 결함 
: 문서 결함 

# 결함 상태 추적
: 결함 분포 > 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정
: 결함 추세 > 테스트 진행 시간에 따른 결함 수의 추이 분석
: 결함 에이징 > 특정 결함 상태로 지속되는 시간 측정

# 어플리케이션 성능
: 사용자가 요구한 기능을 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도

# 애플리케이션 성능 측정 지표
: 처리량, 응답시간, 경과시간, 자원 사용률

# 애플리케이션 성능 분석 절차
: 어플리케이션 성능 점검을 위해 성능 테스트 도구와 시스템 모니터링 도구의 유형 파악후 그 특징을 정리
: 성능 점검의 개요, 수행 전략, 수행 일정 및 절차, 수행 방식 등을포함하여 어플리케이션 성능 점검 계획서 작성 
: 어플리케이션 성능 측정을 위한 테스트 케이스 작성
: 어플리케이션 성능 테스트 결과 분석
: 어플리케이션 성능 저하 요인을 찾아 분석 

# 클린 코드
: 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드

# 나쁜 코드 
: 프로그램의 로직이 복잡하고 이해하기 어려운 코드로 코드의 로직이 서로 얽혀 있는 스파게티 코드, 동일한 처리 로직이 중복되게 작성된 코드 

# 클린코드 작성원칙 
: 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화

# 소프트웨어 개발 보안 목표
: 기밀성, 무결성, 가용성을 유지하는 것

# SDLC
: 소프트웨어 개발 생명주기(Software Development Life Cycle)
: 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수등의 전 과정을 각 단계별로 나눈 것

# 보안 요소
: 기밀성, 무결성, 가용성, 인증, 부인방지

# 시큐어 코딩
: 소프트웨어 구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안 요소들을 고려하여 코딩하는 것을 의미 
: 안전성과 신뢰성 확보를 위해 사용 

# 세션 
: 서버와 클라이언트의 연결 

# 세션 통제
: 세션의 연결과 연결로 인해 발생하는 정보의 관리를 의미

# 세션 설계시 고려사항
: 시스템의 모든 페이지에서 로그아웃 가능하도록 UI 구성
: 로그아웃 요청시 할당된 세션이 완전히 제거되도록 한다
: 세션 타임아웃은 중요도가 높으면 2-5분, 낮으면 15-30분으로 설정 
: 이전 세션이 종료되지 않으면 새로운 세션이 생성되지 못하도록 설계
: 중복 로그인을 허용하지 않은 경우 클라이언트 중복 접근에 대한 세션 관리 정책 수립 

# 잘못된 세션에 의한 정보 노출 방지기법
: 멤버 변수보다 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지 

# 입력 데이터 검증 및 표현
: 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목

# SQL 삽입
: 입력란에 SQL을 삽입하여 무단으로 DB를 조회하거나 조작하는 보안 약점
: 예약어 및 특수문자 필터링을 통하여 방지할 수 있음

# 경로 조작 및 자원 삽입
: 데이터 입출력 경로 조작을 통해 서버 자원을 수정, 삭제할 수 있는 보안 약점이다
: 사용자 입력값을 식별자로 사용하는 경우 경로 순회 공격을 막는 필터를 사용하여 방지한다 

# 크로스사이트 스크립팅(XSS)
: 웹페이지에 악의적인 스크립트를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
: HTML 태그 사용 제한 or 특정 문자들을 다른 문자로 치환함으로서 방지 가능

# 운영체제 명령어 삽입
: 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나 시스템 장애를 유발하는 보안 약점
: 웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 하고, 외부 입력값을 검증없이 내부 명령어로 사용하지 않음으로 방지가능

# 위험한 형식 파일 업로드
: 악의적 명령어가 포함된 스크립트 파일을 업로드 함으로써 시스템에 손상을 주거나, 시스템을 제어할 수 있는 보안 약점
: 업로드 되는 파일의 확장자 제한, 파일명 암호화, 웹사이트와 파일 서버의 경로 분리, 실행속성을 제거하는 등의 방법으로 방지

# 신뢰되지 않는 URL 주소로 자동접속 연결
: 입력값으로 사이트 주소를 받는 경우 이를 조작하여 방문자를 피싱 사이트로 유도하는 보안 약점 
: 외부 사이트 주소를 화이트 리스트로 관리함으로서 방지가능 

# SEED
: 1999년 한국인터넷진흥원에서 개발한 블록 암호화 알고리즘

# ARIA
: 2004년 국가정보원과 산학연합회가 개발한 블록 암호화 알고리즘

# DES
: 1975년 미국 NBS에서 발표한 개인키 암호화 알고리즘
: 블록의 크기는 64비트이고, 키 길이는 56비트

# AES 
: 2001년 NIST에서 발표한 개인키 암호화 알고리즘
: DES의 한계를 느낀후 NIST에서 공모하여 발표

# RSA 
: 1978년 MIT의 Rivest, Shamir, Adelman에 의해 제안된 공개키 암호화 알고리즘 
: 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만듦

# IT보안인증사무국
: 정보보호제품의 평가, 인증을 수행하고 인증제품 목록을 공개 및 관리하는 국가보안기술연구소 산하의 인증기관

# SSL (Secure Sockets Layer)
: 데이터를 송수신하는 두 컴퓨터 사이에 위치하여 인증, 암호화, 무결성을 보장하는 업계 표준 프로토콜 

# default password
: 사용자를 등록하기 전에 설치 권한을 획득하기 위해 사용되는 초기 설정 암호 

# TOCTOU 경쟁 조건
: 검사시점(Time Of Check)과 사용시점(Time Of Use)를 고려하지 않고 코딩하는 경우 발생하는 보안약점
: 검사 시점에는 사용 가능했던 자원이 사용시점에는 사용할 수 없게 된 경우 발생
: 동기화 오류, 교착상태 등이 발생할 수 있음 

# 종료되지 않는 반복문 또는 재귀함수 방지기법
: 모든 반복문이나 재귀함수의 수행 횟수를 제한하는 설정을 추가하거나, 종료 조건을 점검하여 반복 또는 호출의 종류 여부를 확인함으로서 방지가능

# 스택 트레이스
: 오류가 발생한 위치를 추적하기 위해 소프트웨어가 실행 중에 호출한 메소드의 리스트를 기록한것 

# 오류 상황 대응 부재 
: 소프트웨어 개발 중 예외처리를 하지 않았거나 미비로 인해 발생하는 보안약점 

# 오류 메시지를 통한 정보노출
: 오류 발생으로 실행 환경, 사용자 정보, 디버깅 정보 등의 중요 정보를 SW가 메시지로 외부에 노출하는 보안 약점 
: 해커의 악의적 행위를 도울 수 있고, 해커가 SW의 내부구조를 파악하기 쉽게 해줌

# 부적절한 예외처리
: 함수의 반환값 또는 오류들을 세분화하여 처리하지 않고 광범위하게 묶어 한번에 처리하거나, 누락된 예외가 존재할 때 발생하는 보안 약점

# 힙 메모리
: 소프트웨어가 자유롭게 사용할 수 있는 메모리 공간

# 해제된 자원 사용
: 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점

# 초기화되지 않은 변수 사용
: 변수 선언 후 값이 부여되지 않은 변수를 사용할때 발생하는 보안 약점

# 부적절한 자원 해제
: 자원을 반환하는 코드 누락 or 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점

# 파라미터 
: 메소드의 외부에서 전달된 값을 저장하는 변수 

# 패키지
: 관련 클래스나 인터페이스 등을 하나로 모아둔 것 

# 캡슐화
: 객체의 세부 내용을 외부로부터 은폐함으로서 변경이 발생할 때 오류의 파급 효과를 최소화시키는 기능을 한다
: 객체의 재사용성을 향상시킨다
: 데이터와 데이터를 처리하는 함수를 하나로 묶고 실제 구현 내용 일부를 외부에 감춘다

# 정보은닉
: 캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근 허용하는 것

# 추상화
: 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을두어 모델화 하는 것
: 데이터의 공통된 성질을 추출하여 슈퍼 클래스를 선정하는 개념

# 상속성
: 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
: 하위클래스에서 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 사용 가능

# 다형성
: 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미 
: 객체들은 동일한 메소드 명을 사용하여 같은 의미의 응답을 함

# DNS Lookup 방지기법
: DNS 검색을 통해 도메인 이름을 비교하지 않고 IP 주소를 직접 입력하여 접근함으로 방지가능 

# 취약한 API 방지기법
: 보안 문제로 금지된 함수는 안전한 함수로 대체하고 API의 매뉴얼을 참고하여 보안이 보장되는 인터페이스를 사용함으로 방지가능

# 소프트웨어 패키징
: 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것을 의미 
: 사용자 중심으로 진행
: 향후 관리를 고려하여 모듈화하여 패키징 
: 사용자의 편의성 및 실행 환경을 우선적으로 고려
: 다양한 환경에서 손쉽게 사용될 수 있도록 일반적인 형태로 패키징하여 배포

# 모듈화
: 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리등이 용이하도록 시스템을 각 기능별로 나누는 것을 의미 

# 패키징 작업 순서
: 기능 식별 > 모듈화 > 빌드 진행 > 사용자 환경 분석 > 패키징 및 적용 시험 > 패키징 변경 개선 > 배포

# 빌드
: 소스코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물
: 소스코드 파일들을 컴파일한 후 여러개의 모듈을 묶어 실행 파일로 만드는 과정

# 빌드 자동화 도구 
: 빌드를 포함하여 테스트 및 배포를 자동화 하는 도구
: Ant, Maven, Gradle, Jenkins

# Jenkins
: java 기반의 오픈 소스 
: 서블릿 컨테이너에서 실행되는 서버 기반 도구
: SVN, GIT등 대부분의 형상 관리 도구와 연동이 가능
: 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

# 서블릿 컨테이너
: 클라이언트의 요청을 처리해 주기 위해 서버측에서 실행되는 작은 프로그램인(Server Side Applet) 서블릿을 실행하고 생명주기를 관리하는 역할 

# Gradle
: Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구
: 실행할 처리 명령들을 모아 Task로 만든 후 태스크 단위로 실행
: 빌드 캐시 기능을 지원하여 빌드 속도 향상 가능

# 릴리즈 노트
: 개발과정에서 정리된 릴리즈 정보를 SW의 최종 사용자인 고객과 공유하기 위한 문서

# 릴리즈노트 작성 순서
: 모듈 식별 > 릴리즈 정보 확인 > 릴리즈 노트 개요 작성 > 영향도 체크 > 정식 릴리즈 노트 작성 > 추가 개선 항목 식별

# 클리어링 하우스
: 디지털 저작권 라이선스의 중개 및 발급을 수행하는 곳으로, 디지털 저작물의 이용 내역을 근거로 저작권료 정산 및 분배가 수행된다

# 종량제 방식
: 실제 사용한 양에 따라 요금을 차등 적용하는 방식을 의미 

# DRM (Digital Right Management)
: 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 관리 및 보호기술

# 메타 데이터
: 데이터에 대한 데이터, 즉 데이터에 대한 속성 정보등을 설명하기 위한 데이터 

# 패키저(Packager)
: 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램 

# 보안 컨테이너
: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

# DRM Controller
: 배포된 콘텐츠의 이용 권한을 통제하는 프로그램

# 소프트웨어 설치 매뉴얼
: 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서
: 사용자 기준으로 작성
: 설치의 시작부터 완료까지 전 과정을 빠짐없이 순서대로 씀

# 설치 환경 체크 항목
: 사용자 환경
: 응용 프로그램
: 업그레이드 버전
: 백업 폴더 확인

# 소프트웨어 설치 매뉴얼 작성 순서 
: 기능 식별 > UI 분류 > 설치 파일/백업 파일 확인 > Uninstall 절차 확인 > 이상 Case 확인 > 최종 매뉴얼 적용

# Serial
: 소프트웨어를 구별하기 위해 할당된 일련의 고유한 번호

# 패치(Patch)
: 이미 제작하여 배포된 프로그램의 오류 수정이나 성능 향상을 위해 프로그램의 일부 파일을 변경하는 것을 의미 

# 컴포넌트(Component)
: 독립적인 업무 또는 기능을 수행하는 단위, 실행 코드 기반으로 작성된 모듈

# 컴포넌트 명세서
: 컴포넌트의 개요 및 내부 클래스의 동작, 외부와의 통신 명세 등을 정의한 문서 

# 컴포넌트 구현 설계서
: 컴포넌트 구조도, 컴포넌트 목록, 컴포넌트 명세, 인터페이스 명세로 구성된 설계서

# 사용자 매뉴얼 작성 순서
: 기능 식별 > 사용자 화면 분류 > 사용자 환경 파일 확인 > 초기화 절차 확인 > 이상 Case 확인 > 최종 매뉴얼 적용

# 형상관리(SCM: Software Configuration Management)
: 소프트웨어 개발 과정에서 소프트웨어의 변경 사항을 체계적으로 추적하고 통제하는 것 

# 형상 관리 기능
: 형상 식별
: 버전 제어
: 형상 통제(변경 관리)
: 형상 감사
: 형상 기록(상태 보고)

# 소프트웨어 버전 등록 과정
: 가져오기(Import) > 인출(Check-Out) > 예치(Commit) > 동기화(Update) > 차이(Diff)

# 공유 폴더 방식
: 버전관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
: 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사
: SCCS, RCS, PVCS, QVCS

# 클라이언트/서버 방식
: 버전관리 자료가 서버에 저장되어 관리되는 방식
: 서버의 자료를 PC로 복사하여 작업 후 변경된 내용을 서버에 반영
: 서버에서 모든 버전 관리를 수행
: CVS, SVN, CVSNT, Clear Case, CMVC, Perforce

# 분산저장소 방식
: 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식
: 로컬에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업 가능
: Git, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, BitKeeper, Plastic SCM

# Revision
: 커밋의 버전으로, 처음 저장소를 만들면 리비전은 0이 되고 이후 커밋이 수행될 때마다 +1 된다

# SVN
: CVS를 개선한 것으로, 아파치 재단에서 2000년에 발표함
: 클라이언트/서버 구조
: 소스가 오픈되어 무료 사용 가능
: 개발 작업은 trunk 디렉터리에서 수행되며 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업 후 trunk에 merge

# GIT
: 리누스 토발즈가 2005년에 개발하고 주니오 하마노에 의해 유지보수되는 중
: 파일의 변화를 스냅샷으로 저장한다
: 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅이 가능 

# 스테이징 영역
: 작업 내용을 바로 commit하지 않고 해당 영역에 저장했다가 commit을 한다
: 시간이 좀 더 소요되지만 좀 더 안정된 버전 관리 작업이 가능하다

# 운영체제(OS : Operating System)
: 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임

# 스케줄링
: 어떤 자원을 누가, 언제, 어떤 방식으로 사용할지를 결정

# 운영체제의 목적
: 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축

# 운영체제 평가기준
: 처리 능력, 반환 시간, 사용 가능도, 신뢰도

# 단일 작업 처리 시스템
: 컴퓨터 시스템을 한 개의 작업이 독점하여 사용하는 방식
: MS-DOS

# 다중 작업 처리 시스템
: 여러 개의 프로그램을 열어 두고 다양한 작업을 동시에 진행하는 방식
: Windows, UNIX, LINUX, MacOS

# 운영체제의 자원 관리 기능
: 프로세스 관리 > 프로세스 스케줄링 및 동기화 관리 담당
               > 프로세스 생성과 제거, 시작과 정지, 메시지 전달 등의 기능 담당
: 기억장치 관리 > 프로세스에게 메모리 할당 및 회수 관리 담당
: 주변장치 관리 > 입출력장치 스케줄링 및 전반적인 관리 담당
: 파일 관리 > 파일의 생성과 삭제, 변경, 유지 등의 관리 담당

# Kernel
: UNIX의 가장 핵심적인 부분
: 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행
: 하드웨어를 보호하고, 프로그램과 하드웨어간의 인터페이스 역할 담당

# Shell
: 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
: 시스템과 사용자간의 인터페이스 담당
: 파이프라인 기능 지원

# 반입 전략
: 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략

# 요구 반입
: 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법 

# 예상 반입
: 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법

# 배치 전략
: 새로 반입될 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략

# 최초 적합
: 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫번째 분할 영역에 배치시키는 방법

# 최적 적합
: 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법

# 최악 적합
: 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

# 단편화
: 주기억장치의 분할된 영역에 프로그램이나 데이터를 할당할 경우, 분할된 영역이 프로그램이나 데이터보다 작거나 커서 생기는 빈 기억 공간을 의미

# 교체 전략
: 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략
: FIFO, OPT, LRU, LFU, NUR, SCR

# 프로세스
: 프로세서에 의해 처리되는 프로그램, 즉 실행중인 프로그램을 의미하며 작업(Job), 태스크(Task)라고도 한다

# 비동기적 행위
: 다수의 프로세스가 서로 규칙적이거나 연속적이지 않고 독립적으로 실행되는 것을 말한다

# PID
: 프로세스가 시작할 때 할당받는 프로세스 고유번호로 시스템에서 유일한 값을 가짐 

# OSI 참조 모델
: 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약
: 물리 > 데이터 링크 > 네트워크 > 전송 > 세션 > 표현 > 응용 계층으로 이루어짐

# 물리 계층
: 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙 정의
: 리피터, 허브

# 데이터링크 계층
: 두개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 한다
: 흐름제어, 프레임 동기화, 오류제어, 순서제어 기능을 함
: 랜카드, 브리지, 스위치

# 네트워크 계층
: 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함 
: 경로설정, 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행
: 라우터

# 전송 계층
: 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템 간에 투명한 데이터 전송을 가능하게 함 
: TCP, UDP
: 게이트웨이

# 세션 계층
: 송수신 측 간의 관련성을 유지하고 대화 제어를 담당
: 대화 구성 및 동기제어, 데이터 교환 관리 기능을 함 

# 표현 계층
: 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층 
: 응용계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함 

# 응용 계층 
: 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공 
: 응용 프로세스간의 정보교환, 전자사서함, 파일전송, 가상터미널 등의 서비스를 제공 

# 자료흐름도
: 요구사항의 분석에서 자료의 흐름 및 변환 과정과 기능을 도형을 중심으로 기술하는 방법

# 카디널리티
: 릴레이션 튜플개수, 행의 개수 ㅡ 

# 차수(degree)
: 릴레이션 속성의 차수, 속성의 개수 ㅣ

# Spring Batch
: Spring Source사와 Accenture사가 2007년에 공동으로 개발한 오픈소스 프레임워크 
: 주요 구성 요소 > Job, Job Launcher, Step, Job Repository

# Quartz 스케줄러
: 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리
: 주요 구성 요소 > Scheduler, Job, JobDetail, Trigger

# Cron
: 리눅스의 스케줄러 도구로 crontab 명령어를 통해 작업을 예약할 수 있다

# Teardrop Attack
: 분할된 패킷의 순서를 기록하는 Fragment Offset 값을 변경하여 수신 측에서 재조립시 오류로 인한 과부하를 유도하는 공격 방법이다

# 국부성(locality)
: 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질

# 에이징 기법
: 시스템 내에서 특정 프로세스의 우선순위가 낮아 무한정 기다리게 되는 경우, 한번 양보하거나 기다린 시간에 비례하여 일정 시간이 지나면 우선순위를 한단계씩 높여 가까운 시간 안에 자원을 할당받도록 하는 기법

# 네비게이션
: 사용자가 사이트에서 원하는 정보를 빠르게 찾을 수 있도록 안내하는것

# 디지털 저작권 관리를 위해 사용되는 기술
: 암호화, 키관리, 암호화 파일 생성, 식별 기술, 저작권 표현, 정책 관리, 크랙 방지, 인증

# 자동 변수
: 함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수
: 함수나 블록이 실행되는 동안에만 존재하며 이를 벗어나면 자동으로 소멸
: 초기화 하지 않으면 쓰레기값 저장됨

# 외부 변수
: 현재 파일이나 다른 파일에서 선언된 변수나 함수를 참조하기 위한 변수
: 함수 밖에서 선언
: 함수가 종료된 뒤에소 소멸안함
: 초기화하지 않으면 자동으로 0으로 초기화
: 다른 파일에서 선언된 변수를 참조할 경우 초기화 불가능

# 정적 변수
: 함수나 블록 내에서 선언하는 것과 외부에서 선언하는 것이 있음
: 함수나 블록이 종료된 후에도 값이 소멸하지 않음
: 초기화는 변수 선언시 한번만 가능하고, 초기화 생략하면 자동으로 0이됨

# 레지스터 변수
: 메모리가 아닌 CPU 내부의 레지스터에 기억영역을 할당받는 변수
: 처리속도를 높이기 위해 사용
: 함수나 블록이 실행되는 동안에만 존재
: CPU에 저장되어 메모리 주소를 가질 수 없어서 & 연산자 사용 불가능
: 저장할 레지스터가 없는 경우 자동변수로 취급

# complex
: python 데이터 타입 중 복소수를 나타내기 위한 데이터 타입
: 16byte = 실수(8) + 허수(8)

# spoofing(스푸핑)
: 인터넷 프로토콜인 TCP/IP의 구조적 결함을 이용해 사용자의 권한을 획득 한 후, 정보를 빼가는 방법
: 스팸메일 발송 or 위조사이트 접속 유도 같은 방법을 사용

# snooping(스누핑)
: 네트워크 상에 떠도는 중요한 정보를 몰래 획득하는 행위

# sniffing(스니핑)
: 네트워크 상에서 자신이 아닌 다른 상대방들의 패킷을 훔쳐보는 행위

# 블록체인
: 소규모 데이터들이 P2P 방식을 기반으로 생성된 체인 형태의 연결고리 기반 분산 데이터 저장 환경에 저장하여 누구라도 임의로 수정할 수 없고 누구나 변경의 결과를 열람할수 있는 분산 컴퓨팅 기술

# 작업증명시스템(proof-of-work [POW] system)
: 서비스 요청자로부터 일부 작업을 요구함으로서 DoS 공격과 기타 서비스 악용을 단념하게 만들기 위한 경제적인 수단

# 머클 트리 
: 랄프 머클이라는 사람이 1979년에 만들어낸 개념
: 다른 이름으로는 해시트리
: 데이터의 간편하고 확실한 인증을 위해 사용
: SHA-256 암호화(해시함수) 사용

# PaaS (Platform as a Service)
: 일반적으로 앱의 개발 및 시작과 관련된 인프라를 만들고 유지보수 하는 복잡함 없이 고객이 어플리케이션을 개발, 실행, 관리할 수 있게 하는 플랫폼 제공 형태
: 서비스를 개발 할 수 있는 안정적인 환경과 그 환경을 이용하는 응용 프로그램을 개발 할 수 있는 API까지 제공하는 형태

# SaaS (Software as a Service)
: on-demand software로도 불리며, 소프트웨어 및 관련 데이터는 중앙에 호스팅되고 사용자는 웹 브라우저 등의 클라이언트를 통해 접속하는 형태의 소프트웨어 전달 형태
: 클라우드 환경에서 동작하는 응용프로그램을 클라이언트에게 서비스로 제공하는 형태

# IaaS (Infrastructure as a Service)
: 서버, 스토리지, 네트워크를 가상화 환경으로 만들어, 필요에 따라 인프라 자원을 사용할 수 있게 서비스를 제공하는 형태

# Tvishing
: 스마트 TV의 약점을 이용하여 몰래 악성코드를 심어 TV기능을 악용하는 피싱 방법

# Pharming
: 웹 브라우저에서 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인 정보를 훔치거나 금전적인 피해를 입히게 하는 피싱방법

# 하이브리드 블록체인
: 퍼블릭 블록체인의 한계가 있어 탈중앙화를 다소 희생하고 이용자 편리성과 서비스 중심으로 가기 위한 퍼블릭 블록체인과 프라이빗 블록체인의 혼합 형태의 블록체인

# 하둡(Hadoop)
: 분산 환경에서 빅 데이터를 저장하고 처리할 수 있는 자바 기반의 오픈 소스 프레임 워크

# stdio.h 
: C언어 라이브러리
: 데이터 입출력에 사용되는 기능들 제공
: printf, scanf, fprintf, fscanf, fclose, fopen

# math.h 
: C언어 라이브러리
: 수학 함수들을 제공
: sqrt, pow, abs 

# string.h 
: C언어 라이브러리
: 문자열 처리에 사용되는 기능들을 제공
: strlen, strcpy, strcmp

# stdlib.h 
: C언어 라이브러리
: 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공
: atoi, atof, srand, rand, malloc, free

# time.h 
: C언어 라이브러리
: 시간 처리에 사용되는 기능들을 제공 
: time, clock

# java.lang 
: Java 라이브러리
: 기본적으로 필요한 인터페이스, 자료형, 예외 처리등에 관련된 기능을 제공
: import 없이도 사용 가능
: String, System, Process, Runtime, Math, Error

# java.util 
: Java 라이브러리
: 날짜처리, 난수발생, 복잡한 문자열 처리 등에 관련된 기능을 제공
: Date, Calendat, Random, StringTokenizer 

# java.io 
: Java 라이브러리 
: 파일 입출력과 관련된 기능 및 프로토콜을 제공 
: InputStream, OutputStream, Reader, Writer 

# java.net 
: Java 라이브러리
: 네트워크와 관련된 기능을 제공 
: Socket, URL, InetAddress 

# java.awt 
: Java 라이브러리
: 사용자 인터페이스와 관련된 기능을 제공
: Frame, Panel, Dialog, Button, Checkbox

# 내장함수
: python 기본 인터페이스로서 import문이나 클래스명 없이도 사용할 수 있음
: abs(), slice(), pow(), print() 

# os
: 운영체제와 상호 작용하기 위한 기능을 제공한다
: getcwd(), chdir(), system() 

# re 
: 고급 문자열 처리를 위한 기능을 제공한다
: findall(), sub()

# math
: 복잡한 수학 연산을 위한 기능을 제공 
: cos(), log() 

# random
: 무작위 선택을 위한 기능을 제공
: choice(), sample(), random(), randrange()

# statistics
: 통계값 산출을 위한 기능을 제공 
: mean(), median(), variance()

# datetime
: 날짜와 시간 조작을 위한 기능을 제공
: today(), date(), strftime()

# 절차적 프로그래밍 언어 장점
: 컴퓨터 처리 구조와 유사하여 실행 속도가 빠르다
: 같은 코드를 복사하지 않고 다른 위치에서 호출하여 사용할 수 있다 
: 모듈 구성이 용이하며, 구조적인 프로그래밍이 가능하다 

# 절차적 프로그래밍 언어 단점 
: 프로그램을 분석하기 어렵다
: 유지 보수나 코드의 수정이 어렵다

# C 
: 1972년 미국 벨 연구소의 데니스 리치에 의해 개발
: 컴파일러 방식의 언어
: 고급 프로그래밍 언어이면서 저급 프로그래밍 언어의 특징을 모두 갖춤
: 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램을 작성 가능
: 자료의 주소를 조작할 수 있는 포인터 제공

# ALGOL
: 수치계산이나 논리연산을 위한 과학 기술 계산용 언어 
: PASCAL과 C언어의 모체

# COBOL
: 사무 처리용 언어
: 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉽다
: 4개의 DIVISION으로 구성

# FORTRAN
: 과학 기술 계산용 언어
: 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 가능

# Java
: 분산 네트워크 환경에 적용이 가능하며, 멀티스레드 기능을 제공하므로 여러 작업을 동시에 처리 가능
: 운영체제 및 하드웨어 독립적이며, 이식성이 강함 
: 캡슐화가 가능하고 재사용성이 높음 

# C++
: C언어에 객체지향 개념을 적용한 언어
: 모든 문제를 객체로 모델링하여 표현

# Smalltalk
: 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어
: 최초로 GUI를 제공한 언어 

# 스크립트 언어의 장점
: 컴파일이 없이 바로 실행하므로 결과를 바로 확인 가능
: 배우고 코딩하기 쉬움 
: 개발시간이 짧다
: 소스코드를 쉽고 빠르게 수정할 수 있다 

# 스크립트 언어의 단점
: 코드를 읽고 해석해야하므로 속도가 느리다
: 런타임 오류가 많이 발생한다

# 자바스크립트 
: 넷스케이프의 브렌던 아이크가 개발한 클라이언트용 스크립트 언어
: 웹 페이지의 동작을 제어하며, 변수 선언이 필요 없다 
: 서버에 데이터를 전송할 때 아이디, 비밀번호, 수량 등의 입력 사항을 확인하기 위한 용도로 많이 사용됨

# ASP(Active Server Page)
: 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 마이크로소프트 사에서 제작하였다 
: Windows 계열에서만 수행 가능한 프로그래밍 언어이다

# JSP(Java Server Page)
: Java로 만들어진 서버용 스크립트 언어로, 다양한 운영체제에서 사용이 가능하다 

# PHP(Professional Hypertext Preprocessor)
: 서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용이 가능하다 
: C, Java 등과 문법이 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용된다 

# python
: 객체지향 기능을 지원하는 대화형 인터프리터 언어로 플랫폼에 독립적이고 문법이 간단하여 배우기 쉽다 

# 명령형 언어
: 순차적인 명령 수행을 기본으로 하는 언어
: 문제를 처리하기 위한 방법에 초점을 두고 코드를 작성한다
: 폰노이만 구조에 개념적인 기초를 두고 있으며, 알고리즘을 명시하고 목표는 명시하지 않는다

# 선언형 언어의 장점
: 가독성이나 재사용성이 좋다
: 작동 순서를 구체적으로 작성하지 않기 때문에 오류가 적다
: 프로그램 동작을 변경하지 않고도 관련 값을 대체할 수 있다 

# HTML
: 인터넷의 표준 문서인 하이퍼텍스트 문서를 만들기 위해 사용하는 언어로, 특별한 데이터 타입이 없는 단순한 텍스트이므로 호환성이 좋고 사용이 편리하다

# LISP
: 인공지능 분야에서 사용되는 언어이다
: 기본 자료구조가 연결리스트 구조이며, 재귀호출을 많이 사용한다

# PROLOG 
: 논리학을 기초로 한 고급 언어로, 인공 지능 분야에서의 논리적인 추론이나 리스트 처리 등에 주로 사용된다 

# XML 
: 기존 HTML의 단점을 보완하여 웹에서 구조화된 폭넓고 다양한 문서들을 상호 교환할 수 있도록 설계된 언어이다 
: HTML에 사용자가 새로운 태그를 정의할 수 있으며, 문서의 내용과 이를 표현하는 방식이 독립적이다

# Haskell
: 함수형 프로그래밍 언어로 부작용이 없다 
: 코드가 간결하고 에러 발생 가능성이 낮다

# ClassNotFoundException
: 클래스를 찾지 못한 경우

# NoSuchMethodException
: 메소드를 찾지 못한 경우

# FileNotFoundException
: 파일을 찾지 못한 경우

# InterruptedIOException
: 입출력 처리가 중단된 경우

# ArithmeticException
: 산술 연산에 대한 예외가 발생한 경우

# IllegalArgumentException
: 잘못된 인자를 전달한 경우

# NumberFormatException
: 숫자 형식으로 변환할 수 없는 문자열을 숫자 형식으로 변환한 경우

# ArrayIndexOutOfBoundsException
: 배열의 범위를 벗어난 접근을 시도한 경우

# NegativeArraySizeException
: 0보다 작은 값으로 배열의 크기를 지정한 경우

# NullPointerException
: 존재하지 않는 객체를 참조한 경우

# 메타 데이터 관리 시스템
: 메타 데이터를 수집하거나 여러 사람이 메타 데이터를 편리하게 사용할 수 있도록 제공하는 시스템

# 비트맵 인덱스
: 인덱스 컬럼의 데이터를 Bit 값 0 또는 1로 변환하여 인덱스 키로 사용하는 방법

# 함수 기반 인덱스
: 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것

# 비트맵 조인 인덱스
: 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름 

# 도메인 인덱스
: 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스라고도 함 

# 인덱스 설계 순서
: 인덱스의 대상 테이블이나 컬럼 등을 선정
: 인덱스의 효율성을 검토하여 인덱스 최적화를 수행 
: 인덱스 정의서를 작성 

# 이력성 데이터
: 수명이 다되어 데이터베이스에서는 삭제되었지만 데이터 관리 및 업무 규칙에 따라 별도의 저장장치에 보관되는 데이터

# local partitioned index 
: 테이블 파티션과 인덱스 파티션이 1:1 대응되도록 파티셔닝한다 

# global partitioned index
: 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝한다

# 코드 매핑 및 데이터 변환 시점
: 송신 시스템에서 인터페이스 테이블이나 파일을 생성할 때
: 수신 시스템에서 수신 받은 연계 데이터를 운영 DB에 반영할 때
: 연계 서버를 설치할 때 

# 로그 파일 기록하는 이유 
: 연계 데이터가 올바르게 생성 및 추출되어 정상적으로 송수신되고, 운영 DB에 올바르게 반영되었는지를 확인하기 위해 
: 송수신 과정에서 오류 발생 시 오류 발생 원인과 현황을 분석하여 오류 데이터를 재작업하기 위해 

# 패킷
: 전송 혹은 다중화를 목적으로, 데이터를 일정한 크기로 분할하여 송수신측 주소와 제어 정보등을 부가하여 만든 데이터 블록 

# 전송 구간 보안
: 전송되는 데이터나 패킷을 쉽게 가로챌 수 없도록 암호화 기능이 포함된 프로토콜을 사용하거나, 데이터 패킷을 가로채더라도 내용을 쉽게 확인할 수 없도록 데이터나 패킷을 암호화하는 연계 데이터 보안 방식

#  서비스 지향 아키텍처 (SOA: Service Oriented Architecture)
: 기업의 소프트웨어 인프라인 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처를 의미 

# UI 스타일 가이드
: 개발자나 디자이너들이 UI를 작성할 때 기준이 되는 규칙들

# UI 스타일 가이드 작성 순서
: 구동 환경 정의 > 레이아웃 정의 > 네비게이션 정의 > 기능 정의 > 구성요소 정의

# 소프트웨어개발 보안 역할(행정안전부)
: 소프트웨어 개발 보안 정책 총괄 
: 소프트웨어 개발 보안 관련 법규, 지침, 제도 정비
: 소프트웨어 보안 약점을 진단하는 사람의 양성 및 관련 업무 수행 

# 소프트웨어개발 보안 역할(한국인터넷진흥원) 
: 소프트웨어 개발 보안 정책 및 가이드 개발 
: 소프트웨어 개발 보안에 대한 기술 지원 및 교육과정 및 자격제도 운영 

# 소프트웨어개발 보안 역할(발주기관)
: 소프트웨어 개발 보안의 계획 수립 
: 소프트웨어 개발 보안 사업자 및 감리법인 선정 
: 소프트웨어 개발 보안의 준수 여부 점검 

# 소프트웨어개발 보안 역할(사업자)
: 소프트웨어 개발 보안 관련 기술 수준 및 적용 계획 명시 
: 소프트웨어 개발 보안 관련 인력을 대상으로 교육 실시 
: 소프트웨어 개발 보안 가이드를 참조하여 개발 
: 자체적으로 보안약점을 진단하고 제거 
: 소프트웨어 보안약점과 관련된 시정 요구사항을 이행 

# 소프트웨어개발 보안 역할(감리법인)
: 감리 계획을 수립하고 혐의 
: 소프트웨어 보안 약점의 제거 여부 및 조치 결과를 확인

# 기밀성
: 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용됨 
: 정보가 전송중에 노출되더라도 데이터를 읽을 수 없음

# 무결성
: 시스템 내의 정보는 오직 인가된 사용자만 수정가능

# 가용성
: 인가받은 사용자는 언제라도 사용가능 

# 인증
: 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위를 말함
: 대표적 방법으로는 패스워드, 인증용 카드, 지문 검사가 있음 

# 부인방지
: 데이터를 송수신한자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공

# 시큐어코딩
: 소프트웨어의 구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안 요솓릉르 고려하여 코딩하는 것

# JMeter
: HTTP, FTP등 다양한 프로토콜을 지원하는 부하 테스트 도구
: Cross-Platform

# LoadUI
: 서버 모니터링, Drag&Drop등 사용자의 편리성이 강화된 부하 테스트 도구
: HTTP, JDBC등 다양한 프로토콜 지원 
: Cross-Platform

# OpenSTA
: HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링 도구

# 네트워크 인터페이스 카드(NIC)
: 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치
: 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경
: LAN카드라고도 함

# 허브
: 가까운 거리의 컴퓨터들을 연결하는 장치
: 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함

# 더미허브
: 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만을 제공
: LAN이 보유한 대역폭을 컴퓨터 수만큼 나누어 제공
: 네트워크에 연결된 각 노드를 물리적인 성형 구조로 연결 

# 스위칭허브
: 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브 

# 리피터
: 전송되는 신호가 전송 선로의 특성 및 외부 충격등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행
: OSI 참조 모델의 물리 계층에서 동작 

# 브리지 
: LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연결하는 기능을 수행 
: 네트워크 상의 많은 단말기들에 의해 발생되는 트래픽 병목 현상을 줄일 수 있음
: 브리지를 이용한 서브넷 구성 시 전송 가능한 회선수는 브리지가 n개 일때 n(n-1)/2 이다.

# 스위치
: 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치
: 하드웨어 기반으로 처리하여 전송 속도가 빠르다
: 데이터 링크 계층에서 사용됨

# MAC주소
: 네트워크 어댑터(NIC)의 고유번호를 말한다

# 라우터
: 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것
: 네트워크 계층에서 동작하는 장비 

# 게이트웨이
: 전 계층의 프로토콜 구조가 다른 네트워크의 연결을 수행
: 데이터 형식 변환, 주소변환, 프로토콜 변환 등을 수행

# 프로토콜 
: 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약 

# 프로토콜의 특징
: 단편화, 재조립, 캡슐화, 연결 제어, 오류제어, 동기화, 다중화, 주소지정 등이 있음
 
# 프로토콜의 기본 요소
: 구분 > 전송하고자하는 데이터 형식, 부호화, 신호 레벨 등을 규정
: 의미 > 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정 
: 시간 > 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정

# 분석모델 검증
: 유스케이스 모델 검증 > 개념수준 분석 클래스 검증 > 분석 클래스 검증 

# UML의 특징
: 가시화, 구축, 명세화, 문서화 

# SRS
: 요구사항과 스펙을 정리한 산출물로서 소프트웨어 프로젝트의 중심이 되는 SW 요구 사항 명세 문서

# APM
: 운영 중인 시스템에 대한 가용성 확보, 다운타임 최소화 등을 통해 안정적인 시스템 운영을 위하여 부하량과 접속자 파악 및 장애진단 등을 목적으로 하는 성능 모니터링 도구

# APM 유형
: 리소스 모니터링, End to End 모니터링

# 리소스 모니터링
: 모니터링 대상 자원은 CPU, 메모리, 네트워크, 디스크 등이 있음
: 대표적 오픈 소스로는 Nagios, Zabbix, Cacti등이 있음

# End to End 모니터링
: 애플리케이션 수행 관점으로 보고 비즈니스 트랜잭션 관리 및 최종 사용자등을 말한다
: 대표적 오픈 소스로는 VisualVm이 있고, 상용제품으로는 제니퍼, 파로스, 시스마스터 등이 있다

# 옵티마이저
: SQL문의 문법적 오류를 확인하고 가장 빠른 실행 계획을 찾아 주는 역할을 하는 DBMS의 핵심 엔진

# Stored Function
: 보통 값을 계산하고 결과값을 반환하기 위해서 많이 사용
: 반드시 반환될 값의 데이터 타입을 RETURN문에 선언해야함 
: PL/SQL 블록 내에서 Return문을 통해서 반드시 값을 반환해야함 

# Stored Procedure
: 특정 작업을 수행할 수 있는 이름이 있는 PL/SQL 블록
: 매개 변수를 받을 수 있고 반복적으로 사용할 수 있는 Object
: 연속실행 또는 구현이 복잡한 트랜잭션을 수행하는 PL/SQL 블록을 DB에 저장하기 위해 생성

# Stored Package
: 오라클 데이터베이스에 저장되어 있는 서로 관련있는 PL/SQL 프로시저와 함수들의 집합

# TKPROF
: SQL Trace가 생성한 trace 파일을 분석하여 사용자가 읽을 수 있는 형태로 변환시켜 주는 Oracle 제공 도구

# Explain Plan
: 사용자들이 SQL문의 액세스 경로를 확인하여 성능 개선을 할 수 있도록 SQL문을 분석하고 해석하여 실행 계획을 수립하고 관련 테이블에 저장하도록 지원해 주는 도구 

# SQL 성능개선 순서 
: 문제 있는 SQL 식별 > 옵티마이저 통계 확인 > 실행계획검토 > SQL문 재구성 > 인덱스 재구성 > 실행계획 유지관리

# 블록 암호화
: 평문을 일정한 블록단위로 나누어 각 블록마다 암호화 과정을 수행
: 고정된 크기의 블록 단위의 암호문을 생성 
: DES, SEED, ARIA, AES

# 스트림 암호화
: 평문과 같은 길이의 키 스트림을 생성하여 평문과 키 이진 수열을 비트단위로 배타적 논리합 이진 연산으로 결합하여 암호문 생성
: LFSR, SEAL, RC4

# 요구공학
: 무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문
: 요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것이 목표

# RTO(recovery time objective)
: 목표복구시간

# Ajax
: 클라이언트와 서버 간 자바스크립트 및 XML을 비동기 방식으로 처리하며 전체 페이지를 새로 고치지 않고도 웹페이지 일부 영역 부분만을 업데이트하는 것을 가능하게 한다

# IPSEC
: 네트워크 트래픽을 IP 계층에서 암호화와 식별성을 제공하며, 네트워크 계층에서의 보안통신규약

# OSPF
: 대표적인 내부 라우팅 프로토콜로 대규모 네트워크에 적합하고 링크 상태 라우팅 프로토콜로도 불리는 라우팅 프로토콜 

# ICMP
: TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜이다
: 해당 호스트가 없거나, 해당 포트에 대기중에 서버 프로그램이 없는 등의 에러 상황이 발생할 경우 IP헤더에 기록되어 있는 출발지 호스트로 이러한 에러에 대한 상황을 보내주는 역할을 수행하게 된다
